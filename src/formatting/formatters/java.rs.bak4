use super::super::{CodeFormatter, FormatResult};
use super::SecureCommandExecutor;
use crate::analysis::ast::SupportedLanguage;
/// Java code formatter using google-java-format
use anyhow::Result;

/// Java formatter implementation using google-java-format
pub struct JavaFormatter {
    executor: SecureCommandExecutor,
}

impl JavaFormatter {
    pub fn new() -> Self {
        Self {
            executor: SecureCommandExecutor::default(),
        }
    }

    /// Get google-java-format configuration arguments with 2025 standards
    fn get_java_format_args(&self) -> Vec<String> {
        vec![
            // Use standard Google Java Style (not AOSP)
            // Read from stdin
            "-".to_string(),
            // Assume filename for diagnostics when formatting stdin
            "--assume-filename".to_string(),
            "stdin.java".to_string(),
            // Fix imports and remove unused ones
            "--skip-sorting-imports".to_string(),
            "false".to_string(),
            "--skip-removing-unused-imports".to_string(),
            "false".to_string(),
            // Reflow long strings for better readability
            "--skip-reflowing-long-strings".to_string(),
            "false".to_string(),
            // Format javadoc for consistency
            "--skip-javadoc-formatting".to_string(),
            "false".to_string(),
        ]
    }
}

impl CodeFormatter for JavaFormatter {
    fn language(&self) -> SupportedLanguage {
        SupportedLanguage::Java
    }

    /// Format Java source code using google-java-format
    ///
    /// # Examples
    /// ```rust,no_run
    /// use rust_validation_hooks::formatting::formatters::java::JavaFormatter;
    /// use rust_validation_hooks::formatting::CodeFormatter;
    ///
    /// let formatter = JavaFormatter::new();
    /// let code = "public class Hello{public static void main(String[]args){System.out.println(\"Hello\");}}";
    /// let result = formatter.format_code(code).unwrap();
    /// // External formatter may be missing; compile-only example
    /// assert!(result.changed || !result.messages.is_empty());
    /// ```
    fn format_code(&self, code: &str) -> Result<FormatResult> {
        // Validate input
        if code.trim().is_empty() {
            return Ok(FormatResult::unchanged(code.to_string()));
        }

        // Check if google-java-format is available - graceful degradation
        if !self.is_available() {
            let mut result = FormatResult::unchanged(code.to_string());
            result
                .messages
                .push("google-java-format formatter not available - skipping Java formatting".to_string());
            return Ok(result);
        }

        // Prepare google-java-format arguments
        let args = self.get_java_format_args();

        // Execute google-java-format with stdin input
        match self
            .executor
            .execute_formatter("google-java-format", &args, Some(code))
        {
            Ok(formatted_code) => {
                let result = FormatResult::new(code.to_string(), formatted_code);
                Ok(result)
            }
            Err(e) => {
                // If google-java-format fails, it might be due to syntax errors
                // Return the original code with error message
                let mut result = FormatResult::unchanged(code.to_string());
                result.messages.push(format!("google-java-format failed: {e}"));
                Ok(result)
            }
        }
    }

    fn is_available(&self) -> bool {
        self.executor.command_exists("google-java-format")
    }

    fn formatter_info(&self) -> String {
        self.executor.get_formatter_version("google-java-format")
    }

    fn default_config(&self) -> Result<String> {
        Ok(r#"# Google Java Format Configuration
# google-java-format enforces the Google Java Style Guide automatically
# It doesn't use configuration files but applies consistent formatting rules

# Key formatting principles:
# - 2 spaces for indentation (not tabs)
# - 100 character line limit
# - Opening braces on same line
# - Consistent spacing and alignment
# - Automatic import organization

# Installation:
# Download from: https://github.com/google/google-java-format/releases
# Usage: google-java-format [options] files...

# Common command line options:
# --assume-filename <filename>  : Assume the input is from this file
# --dry-run                     : Only check if formatting is needed
# --set-exit-if-changed        : Exit with code 1 if formatting changes
# --skip-sorting-imports       : Don't sort imports
# --skip-removing-unused-imports: Don't remove unused imports
# --length <length>            : Line length limit (default: 100)
# --lines <lines>              : Format only specific line ranges

# Integration with IDEs:
# - IntelliJ IDEA: Install google-java-format plugin
# - Eclipse: Import formatting rules from google-java-format
# - VS Code: Use Checkstyle extension with Google style
"#
        .to_string())
    }
}

impl Default for JavaFormatter {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_java_formatter_creation() {
        let formatter = JavaFormatter::new();
        assert_eq!(formatter.language(), SupportedLanguage::Java);
    }

    #[test]
    fn test_empty_code_handling() {
        let formatter = JavaFormatter::new();
        let result = formatter.format_code("").unwrap();
        assert!(!result.changed);
        assert_eq!(result.formatted, "");
    }

    #[test]
    fn test_whitespace_only_code() {
        let formatter = JavaFormatter::new();
        let result = formatter.format_code("   \n\t  \n").unwrap();
        assert!(!result.changed);
    }

    #[test]
    fn test_formatter_info() {
        let formatter = JavaFormatter::new();
        let info = formatter.formatter_info();
        assert!(info.contains("google-java-format"));
    }

    #[test]
    fn test_default_config_generation() {
        let formatter = JavaFormatter::new();
        let config = formatter.default_config().unwrap();
        assert!(config.contains("Google Java Format"));
        assert!(config.contains("indentation"));
        assert!(config.contains("100 character"));
    }

    #[test]
    fn test_java_format_args() {
        let formatter = JavaFormatter::new();
        let args = formatter.get_java_format_args();
        assert!(args.contains(&"--assume-filename".to_string()));
        assert!(args.contains(&"stdin.java".to_string()));
        assert!(args.contains(&"-".to_string()));
        assert!(args.contains(&"--skip-sorting-imports".to_string()));
        assert!(args.contains(&"--skip-removing-unused-imports".to_string()));
        assert!(args.len() > 3); // Should have more arguments for proper Java formatting
    }

    #[cfg(test)]
    mod integration_tests {
        use super::*;

        #[test]
        fn test_simple_java_formatting() {
            let formatter = JavaFormatter::new();

            // Skip if google-java-format is not available
            if !formatter.is_available() {
                eprintln!("Skipping google-java-format integration test - google-java-format not available");
                return;
            }

            let unformatted_code = "public class Hello{public static void main(String[]args){System.out.println(\"Hello, World!\");}}";
            let result = formatter.format_code(unformatted_code);

            match result {
                Ok(format_result) => {
                    // google-java-format should format this code
                    assert!(format_result.changed || format_result.messages.is_empty());

                    // Formatted code should be valid Java
                    assert!(format_result.formatted.contains("public class Hello"));
                    assert!(format_result.formatted.contains("public static void main"));
                }
                Err(e) => {
                    eprintln!("google-java-format formatting failed: {}", e);
                    // This is acceptable if google-java-format has issues with the test environment
                }
            }
        }

        #[test]
        fn test_complex_java_formatting() {
            let formatter = JavaFormatter::new();

            if !formatter.is_available() {
                eprintln!("Skipping google-java-format integration test - google-java-format not available");
                return;
            }

            let complex_code = r#"
import java.util.*;
public class UserService{
private List<User>users=new ArrayList<>();
public void addUser(String name,int age){users.add(new User(name,age));}
public List<User>getAdultUsers(){return users.stream().filter(u->u.getAge()>=18).collect(Collectors.toList());}
static class User{
private String name;private int age;
public User(String name,int age){this.name=name;this.age=age;}
public String getName(){return name;}
public int getAge(){return age;}
}}
"#.trim();

            let result = formatter.format_code(complex_code);

            match result {
                Ok(format_result) => {
                    if format_result.changed {
                        // Check that formatting improved the code structure
                        assert!(format_result.formatted.contains("public class UserService"));
                        assert!(format_result.formatted.contains("static class User"));
                    }
                }
                Err(e) => {
                    eprintln!("google-java-format formatting of complex code failed: {}", e);
                }
            }
        }

        #[test]
        fn test_java_generics_and_annotations() {
            let formatter = JavaFormatter::new();

            if !formatter.is_available() {
                eprintln!("Skipping google-java-format integration test - google-java-format not available");
                return;
            }

            let generics_code = r#"@Service
public class Repository<T extends Entity>{
private Map<Long,T>cache=new HashMap<>();
@Transactional
public Optional<T>findById(Long id){return Optional.ofNullable(cache.get(id));}
public void save(T entity){cache.put(entity.getId(),entity);}
}"#;
            let result = formatter.format_code(generics_code);

            match result {
                Ok(format_result) => {
                    if format_result.changed {
                        // Check that Java generics and annotations are handled correctly
                        assert!(format_result.formatted.contains("@Service"));
                        assert!(format_result.formatted.contains("<T extends Entity>"));
                        assert!(format_result.formatted.contains("@Transactional"));
                    }
                }
                Err(e) => {
                    eprintln!("google-java-format formatting of generics failed: {}", e);
                }
            }
        }

        #[test]
        fn test_java_lambda_and_streams() {
            let formatter = JavaFormatter::new();

            if !formatter.is_available() {
                eprintln!("Skipping google-java-format integration test - google-java-format not available");
                return;
            }

            let lambda_code = "List<String>names=users.stream().filter(u->u.isActive()).map(User::getName).sorted().collect(Collectors.toList());";
            let result = formatter.format_code(lambda_code);

            match result {
                Ok(format_result) => {
                    if format_result.changed {
                        // Check that lambda expressions and method references are preserved
                        assert!(format_result.formatted.contains("->"));
                        assert!(format_result.formatted.contains("::"));
                        assert!(format_result.formatted.contains("stream()"));
                    }
                }
                Err(e) => {
                    eprintln!("google-java-format formatting of lambdas failed: {}", e);
                }
            }
        }

        #[test]
        fn test_syntax_error_handling() {
            let formatter = JavaFormatter::new();

            if !formatter.is_available() {
                eprintln!("Skipping google-java-format integration test - google-java-format not available");
                return;
            }

            let invalid_code =
                "public class Broken {\npublic void method( {\nSystem.out.println(\"missing brace\";\n}"; // Missing closing brace and parenthesis
            let result = formatter.format_code(invalid_code);

            match result {
                Ok(format_result) => {
                    // Should return original code with error message
                    assert!(!format_result.changed);
                    assert_eq!(format_result.formatted, invalid_code);
                    assert!(!format_result.messages.is_empty());
                }
                Err(_) => {
                    // This is also acceptable - formatter detected the error
                }
            }
        }

        #[test]
        fn test_long_method_chains() {
            let formatter = JavaFormatter::new();

            if !formatter.is_available() {
                eprintln!("Skipping google-java-format integration test - google-java-format not available");
                return;
            }

            let long_chain = "Optional<String>result=Optional.of(\"test\").map(String::toUpperCase).filter(s->s.length()>0).map(s->s+\"_processed\").orElse(\"default\");";
            let result = formatter.format_code(long_chain);

            match result {
                Ok(format_result) => {
                    if format_result.changed {
                        // Check that method chains are formatted with proper line breaks
                        // google-java-format should break long chains into multiple lines
                        assert!(format_result.formatted.contains("Optional"));
                        assert!(format_result.formatted.contains("map"));
                        assert!(format_result.formatted.contains("filter"));
                    }
                }
                Err(e) => {
                    eprintln!("google-java-format formatting of method chains failed: {}", e);
                }
            }
        }
    }
}

