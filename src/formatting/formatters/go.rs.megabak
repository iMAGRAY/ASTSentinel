use super::super::{CodeFormatter, FormatResult};
use super::SecureCommandExecutor;
use crate::analysis::ast::SupportedLanguage;
/// Go code formatter using goimports (with gofmt fallback)
use anyhow::Result;

/// Go formatter implementation using goimports with gofmt fallback
pub struct GoFormatter {
    executor: SecureCommandExecutor,
}

impl GoFormatter {
    pub fn new() -> Self {
        Self {
            executor: SecureCommandExecutor::default(),
        }
    }

    /// Get goimports configuration arguments with 2025 standards
    fn get_goimports_args(&self) -> Vec<String> {
        vec![
            // Use simplify option for cleaner code
            "-s".to_string(),
            // Format from stdin
            // No additional arguments needed - goimports reads stdin by default
        ]
    }

    /// Get gofmt fallback arguments
    fn get_gofmt_args(&self) -> Vec<String> {
        vec![
            // Use simplify option for cleaner code
            "-s".to_string(),
            // gofmt reads from stdin by default when no file is specified
        ]
    }
}

impl CodeFormatter for GoFormatter {
    fn language(&self) -> SupportedLanguage {
        SupportedLanguage::Go
    }

    /// Format Go source code using goimports (with gofmt fallback)
    ///
    /// # Examples
    /// ```rust,no_run
    /// use rust_validation_hooks::formatting::formatters::go::GoFormatter;
    /// use rust_validation_hooks::formatting::CodeFormatter;
    ///
    /// let formatter = GoFormatter::new();
    /// let code = "package main\nfunc main(){fmt.Println(\"hello\")}";
    /// let result = formatter.format_code(code).unwrap();
    /// // External formatter may be missing; compile-only example
    /// assert!(result.changed || !result.messages.is_empty());
    /// ```
    fn format_code(&self, code: &str) -> Result<FormatResult> {
        // Validate input
        if code.trim().is_empty() {
            return Ok(FormatResult::unchanged(code.to_string()));
        }

        // Check if any Go formatter is available - graceful degradation
        if !self.is_available() {
            let mut result = FormatResult::unchanged(code.to_string());
            result
                .messages
                .push("Go formatters (goimports/gofmt) not available - skipping Go formatting".to_string());
            return Ok(result);
        }

        // Try goimports first (preferred), then fallback to gofmt
        if self.executor.command_exists("goimports") {
            let args = self.get_goimports_args();
            match self.executor.execute_formatter("goimports", &args, Some(code)) {
                Ok(formatted_code) => {
                    let result = FormatResult::new(code.to_string(), formatted_code);
                    return Ok(result);
                }
                Err(_) => {
                    // Fall through to gofmt
                }
            }
        }

        // Fallback to gofmt
        let args = self.get_gofmt_args();
        match self.executor.execute_formatter("gofmt", &args, Some(code)) {
            Ok(formatted_code) => {
                let result = FormatResult::new(code.to_string(), formatted_code);
                Ok(result)
            }
            Err(e) => {
                // If both formatters fail, return original code with error message
                let mut result = FormatResult::unchanged(code.to_string());
                result.messages.push(format!("Go formatting failed: {e}"));
                Ok(result)
            }
        }
    }

    fn is_available(&self) -> bool {
        // Check if either goimports or gofmt is available
        self.executor.command_exists("goimports") || self.executor.command_exists("gofmt")
    }

    fn formatter_info(&self) -> String {
        if self.executor.command_exists("goimports") {
            match self.executor.get_formatter_version("goimports") {
                version if version.contains("goimports") => {
                    format!("goimports (preferred) {version}")
                }
                _ => "goimports (preferred)".to_string(),
            }
        } else {
            self.executor.get_formatter_version("gofmt")
        }
    }

    fn default_config(&self) -> Result<String> {
        Ok(r#"# Go formatting configuration
# gofmt is the standard Go formatter and doesn't use configuration files
# It applies the Go community's standard formatting rules automatically

# Common Go formatting principles applied by gofmt:
# - Indentation uses tabs (not spaces)
# - No trailing whitespace
# - Standard bracket placement
# - Consistent spacing around operators
# - Proper import grouping and sorting

# Additional tools that can be used with Go:
# - goimports: automatically manages imports
# - golint: provides style suggestions
# - go vet: examines Go source code for suspicious constructs
# - golangci-lint: meta-linter with many useful linters

# To use goimports instead of gofmt for automatic import management:
# go install golang.org/x/tools/cmd/goimports@latest
"#
        .to_string())
    }
}

impl Default for GoFormatter {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_go_formatter_creation() {
        let formatter = GoFormatter::new();
        assert_eq!(formatter.language(), SupportedLanguage::Go);
    }

    #[test]
    fn test_empty_code_handling() {
        let formatter = GoFormatter::new();
        let result = formatter.format_code("").unwrap();
        assert!(!result.changed);
        assert_eq!(result.formatted, "");
    }

    #[test]
    fn test_whitespace_only_code() {
        let formatter = GoFormatter::new();
        let result = formatter.format_code("   \n\t  \n").unwrap();
        assert!(!result.changed);
    }

    #[test]
    fn test_formatter_info() {
        let formatter = GoFormatter::new();
        let info = formatter.formatter_info();
        assert!(info.contains("gofmt"));
    }

    #[test]
    fn test_default_config_generation() {
        let formatter = GoFormatter::new();
        let config = formatter.default_config().unwrap();
        assert!(config.contains("gofmt"));
        assert!(config.contains("formatting"));
        assert!(config.contains("goimports"));
    }

    #[test]
    fn test_gofmt_args() {
        let formatter = GoFormatter::new();
        let args = formatter.get_gofmt_args();
        // gofmt uses -s flag for simplification
        assert!(args.contains(&"-s".to_string()));
        assert_eq!(args.len(), 1);
    }

    #[test]
    fn test_goimports_args() {
        let formatter = GoFormatter::new();
        let args = formatter.get_goimports_args();
        // goimports uses -s flag for simplification
        assert!(args.contains(&"-s".to_string()));
        assert_eq!(args.len(), 1);
    }

    #[cfg(test)]
    mod integration_tests {
        use super::*;

        #[test]
        fn test_simple_go_formatting() {
            let formatter = GoFormatter::new();

            // Skip if gofmt is not available
            if !formatter.is_available() {
                eprintln!("Skipping gofmt integration test - gofmt not available");
                return;
            }

            let unformatted_code =
                "package main\nimport \"fmt\"\nfunc main(){fmt.Println(\"Hello, World!\")}";
            let result = formatter.format_code(unformatted_code);

            match result {
                Ok(format_result) => {
                    // gofmt should format this code
                    assert!(format_result.changed || format_result.messages.is_empty());

                    // Formatted code should be valid Go
                    assert!(format_result.formatted.contains("package main"));
                    assert!(format_result.formatted.contains("func main()"));
                }
                Err(e) => {
                    eprintln!("gofmt formatting failed: {}", e);
                    // This is acceptable if gofmt has issues with the test environment
                }
            }
        }

        #[test]
        fn test_complex_go_formatting() {
            let formatter = GoFormatter::new();

            if !formatter.is_available() {
                eprintln!("Skipping gofmt integration test - gofmt not available");
                return;
            }

            let complex_code = r#"
package main
import("fmt";"os")
type User struct{Name string;Age int}
func processUsers(users []User)[]string{
var names []string
for _,user:=range users{if user.Age>=18{names=append(names,user.Name)}}
return names}
func main(){users:=[]User{{"Alice",25},{"Bob",17}}
fmt.Println(processUsers(users))}
"#
            .trim();

            let result = formatter.format_code(complex_code);

            match result {
                Ok(format_result) => {
                    if format_result.changed {
                        // Check that formatting improved the code structure
                        assert!(format_result.formatted.contains("type User struct"));
                        assert!(format_result.formatted.contains("func processUsers"));
                        assert!(format_result.formatted.contains("func main()"));
                    }
                }
                Err(e) => {
                    eprintln!("gofmt formatting of complex code failed: {}", e);
                }
            }
        }

        #[test]
        fn test_go_interfaces_and_methods() {
            let formatter = GoFormatter::new();

            if !formatter.is_available() {
                eprintln!("Skipping gofmt integration test - gofmt not available");
                return;
            }

            let interface_code = r#"package main
type Writer interface{Write([]byte)(int,error)}
type StringWriter struct{data string}
func(sw *StringWriter)Write(p []byte)(int,error){sw.data+=string(p);return len(p),nil}
"#
            .trim();
            let result = formatter.format_code(interface_code);

            match result {
                Ok(format_result) => {
                    if format_result.changed {
                        // Check that Go-specific syntax is handled correctly
                        assert!(format_result.formatted.contains("interface"));
                        assert!(format_result.formatted.contains("func (sw *StringWriter)"));
                    }
                }
                Err(e) => {
                    eprintln!("gofmt formatting of interfaces failed: {}", e);
                }
            }
        }

        #[test]
        fn test_go_channels_and_goroutines() {
            let formatter = GoFormatter::new();

            if !formatter.is_available() {
                eprintln!("Skipping gofmt integration test - gofmt not available");
                return;
            }

            let concurrent_code = "package main\nfunc worker(ch chan int){for i:=0;i<5;i++{ch<-i}; close(ch)}\nfunc main(){ch:=make(chan int);go worker(ch);for v:=range ch{println(v)}}";
            let result = formatter.format_code(concurrent_code);

            match result {
                Ok(format_result) => {
                    if format_result.changed {
                        // Check that concurrent Go features are preserved
                        assert!(format_result.formatted.contains("chan int"));
                        assert!(format_result.formatted.contains("go worker"));
                        assert!(format_result.formatted.contains("range ch"));
                    }
                }
                Err(e) => {
                    eprintln!("gofmt formatting of concurrent code failed: {}", e);
                }
            }
        }

        #[test]
        fn test_syntax_error_handling() {
            let formatter = GoFormatter::new();

            if !formatter.is_available() {
                eprintln!("Skipping gofmt integration test - gofmt not available");
                return;
            }

            let invalid_code = "package main\nfunc main( {\nfmt.Println(\"broken syntax\""; // Missing closing braces and import
            let result = formatter.format_code(invalid_code);

            match result {
                Ok(format_result) => {
                    // Should return original code with error message
                    assert!(!format_result.changed);
                    assert_eq!(format_result.formatted, invalid_code);
                    assert!(!format_result.messages.is_empty());
                }
                Err(_) => {
                    // This is also acceptable - formatter detected the error
                }
            }
        }

        #[test]
        fn test_package_and_imports() {
            let formatter = GoFormatter::new();

            if !formatter.is_available() {
                eprintln!("Skipping gofmt integration test - gofmt not available");
                return;
            }

            let import_code = r#"package main
import("fmt";"strings";"os")
func main(){name:=os.Args[1];fmt.Println(strings.ToUpper(name))}"#;
            let result = formatter.format_code(import_code);

            match result {
                Ok(format_result) => {
                    if format_result.changed {
                        // Check that imports are formatted properly
                        assert!(format_result.formatted.contains("package main"));
                        assert!(format_result.formatted.contains("import"));
                        // gofmt should format imports properly
                    }
                }
                Err(e) => {
                    eprintln!("gofmt formatting of imports failed: {}", e);
                }
            }
        }
    }
}

