{"session_id":"9cf14753-dc5d-445f-8258-494f46d6a623","transcript_path":"C:\\Users\\1\\.claude\\projects\\C--Users-1-Documents-GitHub-ValidationCodeHook\\9cf14753-dc5d-445f-8258-494f46d6a623.jsonl","cwd":"C:\\Users\\1\\Documents\\GitHub\\ValidationCodeHook","permission_mode":"bypassPermissions","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"C:\\Users\\1\\Documents\\GitHub\\ValidationCodeHook\\src\\formatting\\formatters\\rust.rs","old_string":"use std::path::Path;","new_string":""},"tool_response":{"filePath":"C:\\Users\\1\\Documents\\GitHub\\ValidationCodeHook\\src\\formatting\\formatters\\rust.rs","oldString":"use std::path::Path;","newString":"","originalFile":"use super::super::{CodeFormatter, FormatResult};\nuse super::SecureCommandExecutor;\nuse crate::analysis::ast::SupportedLanguage;\n/// Rust code formatter using rustfmt\nuse anyhow::Result;\nuse std::fs;\nuse std::path::Path;\n\n/// Rust formatter implementation using rustfmt\npub struct RustFormatter {\n    executor: SecureCommandExecutor,\n}\n\nimpl RustFormatter {\n    pub fn new() -> Self {\n        Self {\n            executor: SecureCommandExecutor::default(),\n        }\n    }\n\n    /// Get rustfmt configuration arguments based on project configuration\n    /// Dynamically determines edition from Cargo.toml or uses fallback\n    fn get_rustfmt_args(&self) -> Vec<String> {\n        let mut args = vec![];\n\n        // Try to detect edition from Cargo.toml\n        let edition = self\n            .detect_rust_edition()\n            .unwrap_or_else(|| \"2021\".to_string());\n\n        // Set edition to support modern Rust features like async/await\n        args.push(\"--edition\".to_string());\n        args.push(edition);\n\n        // Use stdin for input\n        args.push(\"--\".to_string());\n\n        args\n    }\n\n    /// Detect Rust edition from Cargo.toml or rustfmt.toml\n    fn detect_rust_edition(&self) -> Option<String> {\n        // Try Cargo.toml first (most common)\n        if let Ok(cargo_content) = fs::read_to_string(\"Cargo.toml\") {\n            if let Some(edition) = self.extract_edition_from_toml(&cargo_content) {\n                return Some(edition);\n            }\n        }\n\n        // Try rustfmt.toml as fallback\n        if let Ok(rustfmt_content) = fs::read_to_string(\"rustfmt.toml\") {\n            if let Some(edition) = self.extract_edition_from_toml(&rustfmt_content) {\n                return Some(edition);\n            }\n        }\n\n        // Try .rustfmt.toml as another fallback\n        if let Ok(rustfmt_content) = fs::read_to_string(\".rustfmt.toml\") {\n            if let Some(edition) = self.extract_edition_from_toml(&rustfmt_content) {\n                return Some(edition);\n            }\n        }\n\n        None\n    }\n\n    /// Extract edition value from TOML content\n    fn extract_edition_from_toml(&self, content: &str) -> Option<String> {\n        for line in content.lines() {\n            let line = line.trim();\n            if line.starts_with(\"edition\") && line.contains('=') {\n                if let Some(value_part) = line.split('=').nth(1) {\n                    let value = value_part.trim().trim_matches('\"').trim_matches('\\'');\n                    // Validate that it's a reasonable edition\n                    if matches!(value, \"2015\" | \"2018\" | \"2021\" | \"2024\") {\n                        return Some(value.to_string());\n                    }\n                }\n            }\n        }\n        None\n    }\n}\n\nimpl CodeFormatter for RustFormatter {\n    fn language(&self) -> SupportedLanguage {\n        SupportedLanguage::Rust\n    }\n\n    /// Format Rust source code using rustfmt\n    ///\n    /// # Examples\n    /// ```rust\n    /// use rust_validation_hooks::formatting::formatters::rust::RustFormatter;\n    /// use rust_validation_hooks::formatting::CodeFormatter;\n    ///\n    /// let formatter = RustFormatter::new();\n    /// let code = \"fn main(){println!(\\\"hello\\\");}\";\n    /// let result = formatter.format_code(code).unwrap();\n    /// assert!(result.changed);\n    /// ```\n    fn format_code(&self, code: &str) -> Result<FormatResult> {\n        // Validate input\n        if code.trim().is_empty() {\n            return Ok(FormatResult::unchanged(code.to_string()));\n        }\n\n        // Check if rustfmt is available - graceful degradation\n        if !self.is_available() {\n            let mut result = FormatResult::unchanged(code.to_string());\n            result\n                .messages\n                .push(\"rustfmt formatter not available - skipping Rust formatting\".to_string());\n            return Ok(result);\n        }\n\n        // Prepare rustfmt arguments\n        let args = self.get_rustfmt_args();\n\n        // Execute rustfmt with stdin input\n        match self\n            .executor\n            .execute_formatter(\"rustfmt\", &args, Some(code))\n        {\n            Ok(formatted_code) => {\n                let result = FormatResult::new(code.to_string(), formatted_code);\n                Ok(result)\n            }\n            Err(e) => {\n                // If rustfmt fails, it might be due to syntax errors\n                // Return the original code with error message\n                let mut result = FormatResult::unchanged(code.to_string());\n                result.messages.push(format!(\"rustfmt failed: {}\", e));\n                Ok(result)\n            }\n        }\n    }\n\n    fn is_available(&self) -> bool {\n        self.executor.command_exists(\"rustfmt\")\n    }\n\n    fn formatter_info(&self) -> String {\n        self.executor.get_formatter_version(\"rustfmt\")\n    }\n\n    fn default_config(&self) -> Result<String> {\n        Ok(r#\"# rustfmt configuration\n# This file can be placed as rustfmt.toml or .rustfmt.toml\n\n# Basic formatting options\nmax_width = 100\nhard_tabs = false\ntab_spaces = 4\n\n# Import and use formatting\nimports_layout = \"Mixed\"\ngroup_imports = \"StdExternalCrate\"\nreorder_imports = true\n\n# Code style preferences\nfn_single_line = false\nwhere_single_line = false\nforce_explicit_abi = true\nformat_strings = false\nformat_macro_matchers = true\nformat_code_in_doc_comments = false\n\n# Comment formatting\nnormalize_comments = true\nwrap_comments = true\ncomment_width = 80\n\n# Control flow formatting\nmatch_block_trailing_comma = false\ntrailing_comma = \"Vertical\"\ntrailing_semicolon = true\n\n# Error handling\nerror_on_line_overflow = false\nerror_on_unformatted = false\n\n# Misc options\nedition = \"2021\"\nuse_field_init_shorthand = false\nuse_try_shorthand = false\n\"#\n        .to_string())\n    }\n}\n\nimpl Default for RustFormatter {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_rust_formatter_creation() {\n        let formatter = RustFormatter::new();\n        assert_eq!(formatter.language(), SupportedLanguage::Rust);\n    }\n\n    #[test]\n    fn test_empty_code_handling() {\n        let formatter = RustFormatter::new();\n        let result = formatter.format_code(\"\").unwrap();\n        assert!(!result.changed);\n        assert_eq!(result.formatted, \"\");\n    }\n\n    #[test]\n    fn test_whitespace_only_code() {\n        let formatter = RustFormatter::new();\n        let result = formatter.format_code(\"   \\n\\t  \\n\").unwrap();\n        assert!(!result.changed);\n    }\n\n    #[test]\n    fn test_formatter_info() {\n        let formatter = RustFormatter::new();\n        let info = formatter.formatter_info();\n        assert!(info.contains(\"rustfmt\"));\n    }\n\n    #[test]\n    fn test_default_config_generation() {\n        let formatter = RustFormatter::new();\n        let config = formatter.default_config().unwrap();\n        assert!(config.contains(\"max_width\"));\n        assert!(config.contains(\"tab_spaces\"));\n        assert!(config.contains(\"edition\"));\n    }\n\n    #[test]\n    fn test_rustfmt_args() {\n        let formatter = RustFormatter::new();\n        let args = formatter.get_rustfmt_args();\n        assert!(args.contains(&\"--\".to_string()));\n    }\n\n    #[cfg(test)]\n    mod integration_tests {\n        use super::*;\n\n        #[test]\n        fn test_simple_rust_code_formatting() {\n            let formatter = RustFormatter::new();\n\n            // Skip if rustfmt is not available\n            if !formatter.is_available() {\n                eprintln!(\"Skipping rustfmt integration test - rustfmt not available\");\n                return;\n            }\n\n            let unformatted_code = \"fn main(){println!(\\\"Hello, world!\\\");}\";\n            let result = formatter.format_code(unformatted_code);\n\n            match result {\n                Ok(format_result) => {\n                    // rustfmt should format this code\n                    assert!(format_result.changed || format_result.messages.is_empty());\n\n                    // Formatted code should be valid Rust\n                    assert!(format_result.formatted.contains(\"fn main()\"));\n                    assert!(format_result.formatted.contains(\"println!\"));\n                }\n                Err(e) => {\n                    eprintln!(\"rustfmt formatting failed: {}\", e);\n                    // This is acceptable if rustfmt has issues with the test environment\n                }\n            }\n        }\n\n        #[test]\n        fn test_complex_rust_code_formatting() {\n            let formatter = RustFormatter::new();\n\n            if !formatter.is_available() {\n                eprintln!(\"Skipping rustfmt integration test - rustfmt not available\");\n                return;\n            }\n\n            let complex_code = r#\"\nuse std::collections::HashMap;\nfn process_data(data:Vec<String>)->HashMap<String,usize>{\nlet mut result=HashMap::new();\nfor item in data{result.insert(item.clone(),item.len());}\nresult}\n\"#\n            .trim();\n\n            let result = formatter.format_code(complex_code);\n\n            match result {\n                Ok(format_result) => {\n                    if format_result.changed {\n                        // Check that formatting improved the code structure\n                        assert!(format_result.formatted.contains(\"-> HashMap\"));\n                        assert!(format_result.formatted.contains(\"for item in data\"));\n                    }\n                }\n                Err(e) => {\n                    eprintln!(\"rustfmt formatting of complex code failed: {}\", e);\n                }\n            }\n        }\n\n        #[test]\n        fn test_syntax_error_handling() {\n            let formatter = RustFormatter::new();\n\n            if !formatter.is_available() {\n                eprintln!(\"Skipping rustfmt integration test - rustfmt not available\");\n                return;\n            }\n\n            let invalid_code = \"fn main( { println!(\\\"broken syntax\\\"; }\";\n            let result = formatter.format_code(invalid_code);\n\n            match result {\n                Ok(format_result) => {\n                    // Should return original code with error message\n                    assert!(!format_result.changed);\n                    assert_eq!(format_result.formatted, invalid_code);\n                    assert!(!format_result.messages.is_empty());\n                }\n                Err(_) => {\n                    // This is also acceptable - formatter detected the error\n                }\n            }\n        }\n    }\n}\n","structuredPatch":[{"oldStart":4,"oldLines":7,"newStart":4,"newLines":6,"lines":[" /// Rust code formatter using rustfmt"," use anyhow::Result;"," use std::fs;","-use std::path::Path;"," "," /// Rust formatter implementation using rustfmt"," pub struct RustFormatter {"]}],"userModified":false,"replaceAll":false}}